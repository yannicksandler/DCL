<?php

/**
 * Factura
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id: Builder.php 6820 2009-11-30 17:27:49Z jwage $
 */
class Factura extends BaseFactura
{
    public function setUp()
    {
        parent::setUp();

        $this->hasAccessorMutator('Fecha', 'FechaAccessor', 'FechaMutator');
        $this->hasAccessorMutator('FechaVencimiento', 'FechaVencimientoAccessor', 'FechaVencimientoMutator');
    }
    
    public function FechaAccessor()
    {
    	$timestamp	=	$this->_get('Fecha');
    	
    	if ($timestamp)
    	{
        	$date 	=	new Classes_DateHelper();
        	
        	return $date->toViewFormat($timestamp);
    	}
    	else
    		return '';
    }
    
    
    public function FechaMutator( $value )
    {
        $date 	=	new Classes_DateHelper();
        
        $this->_set('Fecha', $date->fromViewFormat($value));
    }

    public function FechaVencimientoAccessor()
    {
    	$timestamp	=	$this->_get('FechaVencimiento');
    	 
    	if ($timestamp)
    	{
    		$date 	=	new Classes_DateHelper();
    		 
    		return $date->toViewFormat($timestamp);
    	}
    	else
    		return '';
    }
    
    
    public function FechaVencimientoMutator( $value )
    {
    	$date 	=	new Classes_DateHelper();
    
    	$this->_set('FechaVencimiento', $date->fromViewFormat($value));
    }
    
    
	public function GetHeader()
	{
		$r=array();
		
		$r['Cliente'] = $this->Cliente;
		$r['TipoIva'] = $this->Cliente->TipoIva;
		
		return $r;
	}
	
	public function Anular()
	{
		// no anular factura si tiene cobranza
		if($this->TieneCobranzasVigentes())
			throw new Exception('No se puede anular una factura que tiene cobranzas');
		
		$conn = Doctrine_Manager::connection();
		
			//echo 'ejecutar como trans';
			$this->FechaAnulacion = date('Y-m-d');
			
			$q =	Doctrine_Query::create()
						->from('OrdenDeTrabajo ot')
                        ->Update()
                        ->Set('FacturaId', 'NULL')
                        ->andWhere('ot.ClienteId = ?', $this->ClienteId)
                        ->andWhere('ot.FacturaId = ?', $this->Id);
                        
			$conn->beginTransaction();
			
			$this->save();
			//actualizar ordenes asociadas la factura
			$q->execute();
			
			$conn->commit();
		
	}
	
	public function GetResumen()
	{
		$a	= array();
		$a['Cliente'] = $this->Cliente;
		$a['Cuit'] = $this->Cliente->FormatCuit();
		//$a['TipoIva'] = $this->Cliente->TipoIva;
		$a['Factura'] = $this;
		
		$a['Subtotal'] = number_format($this->GetSubtotal(),2,'.','');
		$a['PorcentajeIva'] = $this->GetPorcentajeIva();
		$a['TotalIva'] = number_format($this->GetTotalIva(),2,'.','');
		
		switch ($this->GetLetraFactura())
        {
        		case 'A': 
        			{
        				$a['Ordenes'] = $this->GetOrdenes();
        				break;
        			}
        		case 'B': 
        			{
        				$porcentajeIncluido = ($this->GetPorcentajeIva()/100)+1;
        				$a['Ordenes'] = $this->GetOrdenes();
        				foreach($a['Ordenes'] as $o)
        				{
        					$o->TotalSinIva = $o->TotalSinIva*$porcentajeIncluido;
        				}
        				if($a['Factura']->ComentarioImporte > 0)
        				{
        					$a['Factura']->ComentarioImporte = $a['Factura']->ComentarioImporte*$porcentajeIncluido;
        				}
        				
        				break;
        			}
        		case 'N': 
        			{
        				$a['Ordenes'] = $this->GetOrdenes(); 
        				break;
        			}
        		default: 
        			{
        				$a['Ordenes'] = $this->GetOrdenes(); 
        				break;
        			}
        }
        
		return $a;
	}
	
	public function GetOrdenes()
	{
		$q  =   Doctrine_Query::create()
                    ->from('OrdenDeTrabajo o')
                    ->where('o.FacturaId = ?', $this->Id);
                   
        return $q->execute();
	}
	
	public function GetSubtotal()
	{
		$total = 0;
		
		if($this->TipoIva->GetLetraFactura() == 'A')
		{
			$ordenes = $this->GetOrdenes();
			
			foreach($ordenes as $o)
			{
				$total += $o->TotalSinIva;
			}
			
			if($this->ComentarioImporte > 0)
				$total += $this->ComentarioImporte;
		}
		
		return $total;
	}
	
	public function GetTotalIva()
	{
		$porcentaje = ($this->GetPorcentajeIva()/100);
		
		$subtotal = $this->GetSubtotal();
		
		return ($porcentaje*$subtotal);
	}
	
	public function GetPorcentajeIva()
	{
		return $this->TipoIva->GetPorcentajeIva();
	}
	
	public function GetTotalCobrado()
	{
		$total = 0;
		
		$filters = array();
		$filters['FacturaId']	=	$this->Id;
		$filters['Anuladas']	=	'SI';
		
		$q = Doctrine::getTable('CobranzaLiquidacion')->GetByFilter( $filters );
		
		$cobranzas = $q->execute();
		
		foreach($cobranzas as $c)
		{
			$total += $c->Importe;
		}
		
		return $total;
	}
	
	public function GetLetraFactura()
	{
		return $this->TipoIva->GetLetraFactura();
	}
	
	public function TieneImportePendiente()
	{
		if($this->GetTotalCobrado() < $this->Importe)
		{
			return true;
		}
		
		return false;
	}
	
	public function VerificarCobro()
	{
		if(! $this->TieneImportePendiente())
		{
			$ordenes = $this->GetOrdenes();
			foreach ($ordenes as $o)
			{
				/*
				 * 20130522
				 * o	Soluci칩n (controlar fuga de OT por Cobranza anticipada): 
				 * cuando ingreso una cobranza de una factura que tiene OT, si la OT 
				 * est치 en cualquier estado anterior o igual a Producci칩n, no modificar 
				 * estado ha Cobrado (sino sale de Producci칩n, saltea proceso y se pierde).
				 */
				if(!$o->PermiteCobranzaAnticipada())
				{
					$o->SetEstadoCobrado();
				}
			}
		}
	}
	
	public function GetImportePendienteDeCobro()
	{
		return number_format(($this->Importe - $this->GetTotalCobrado()),2, '.','');
		//return ($this->Importe - $this->GetTotalCobrado());
	}
	
	/* si una factura tiene cobranzas vigentes, no puede anularse
	 * 
	 */
	public function TieneCobranzasVigentes()
	{
		$q  =   Doctrine_Query::create()
		->from('CobranzaLiquidacion cl')
		->innerJoin('cl.Factura f')
		->andWhere('f.FechaAnulacion IS NULL')
		->where('cl.FacturaId = ?', $this->Id);
		 
		$liquidaciones	=	 $q->execute();
		
		if(count($liquidaciones) > 0)
			return true;
		
		return false;
		
		
		
		
	}
	
	public function GetTieneCobranzasVigentes()
	{
		return $this->TieneCobranzasVigentes();
	}
	
	public function GetOrdenesDeTrabajoAsociadas()
	{
		$ordenes	=	'';
		$validadas	=	$this->GetOrdenes();
	
		foreach($validadas as $v)
		{
			$ordenes	=	'<br>(OT '.$v->Id . ')<br>';
		}
	
		return $ordenes;
	}
	
	public function GetCondicionDeCobro()
	{
		$ordenes	=	$this->GetOrdenes();
		
		foreach($ordenes as $o)
		{
			$condicion	=	$o->Presupuesto->FormasDePago;
			
			if($condicion)
				return $condicion;
		}
		
		return 'Sin condicion';
	}
	
	public function GetImporteLiquidadoEnCobranza()
	{
		$s	=	new Classes_Session();
		$s->Session();
		
		$liquidacion = $s->GetFacturasLiquidadasCobranza();
		
		foreach($liquidacion as $f)
		{
			if($f['FacturaNumero'] == $this->Id)
				return number_format($f['ImporteLiquidado'],2, '.','');
		}
	}

	public function getHeadersForExport() {
		return ['Numero','Fecha','Cliente','Importe Total','Por Cobrar','Abonado','Tipo IVA','Estado'];
	}

	/**
	 * Metodo que formatea una factura para enviarla a exportar
	 * @return array
	 */
	public function FormatDataForExport() {
		//Obtenemos las CobranzaLiquidaciones para calcular lo que fue abonado discriminando cada una de ellas
		$cobranzaStr = array();
		if(!empty($this->CobranzaLiquidaciones)){
			foreach($this->CobranzaLiquidaciones as $cobranzaLiq){
				$cobranzaStr[] = "Cobranza #".$cobranzaLiq->Cobranza->Id. " | Importe ". currency($cobranzaLiq->Importe)."\n";
			}
		}else{
			$cobranzaStr[] = '-';
		}

		$formattedData = array(
			$this->Id,
			$this->Fecha,
			utf8_encode($this->Cliente->Nombre),
			currency($this->Importe),
			currency($this->GetImportePendienteDeCobro()),
			implode("", $cobranzaStr),
			$this->GetLetraFactura(),
			'Vigente'
		);

		return $formattedData;
	}
	
}