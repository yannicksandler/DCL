<?php

/**
 * Proveedor
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id: Builder.php 6820 2009-11-30 17:27:49Z jwage $
 */
class Proveedor extends BaseProveedor
{
	public function CrearFacturaCompra($data)
	{
		if(!isset($data))
			throw new Exception('Faltan datos para crear la factura');
		
		//print_r($data);
		
		$ff		=	new Classes_FacturaCompraFactory($this, $data);
		
		$factura	=	 $ff->CrearFactura();
		if(!is_object($factura))
				throw new Exception('No fue creada la factura de compra');
		
		return $factura;
		
		
		
	}
	
	public function ExisteFactura(FacturaCompra $f)
	{
		return Doctrine::getTable('FacturaCompra')->ExisteFactura($f); 
	}
	
	/*
	 * utilizada al liquidar una factura de compra
	 */
	public function GetOrdenesDeCompraPendientes($EnBlanco = null)
	{
		// limpiar ordenes de compra agregadas en sesion
		$s	=	new Classes_Session();
		$s->LimpiarOrdenDeCompraLiquidacionFacturaCompra();
		////////////////////////////////////////////
		$filters		=	array();
		$filters['ProveedorId']	=	$this->Id;
		$filters['EnBlanco']	=	$EnBlanco;
	
		$query		= Doctrine::getTable('OrdenDeCompra')->GetNoAnuladas( $filters );
		$ordenes = $query->execute();
		var_dump(count($query));
		$ordenesCompraPendientes = array();
	
		foreach($ordenes as $o)
		{
			if($o->IsPendienteDeLiquidar())
				$ordenesCompraPendientes[] = $o;
		}
	
	
		return $ordenesCompraPendientes;
	}
	
	public function GetOrdenesDeCompraPendientesEnBlanco()
	{
		return $this->GetOrdenesDeCompraPendientes('SI');
	}
	
	// obtener todas las ordenes de compra de un proveedor que tengan importe pendiente de validar
	public function GetOrdenesDeCompraPendientesDeValidar()
	{
		// limpiar ordenes de compra agregadas en sesion
		$s	=	new Classes_Session();
		$s->LimpiarOrdenDeCompraLiquidacionFacturaCompra();
		////////////////////////////////////////////
		$filters		=	array();
		$filters['ProveedorId']	=	$this->Id;
		//$filters['EnBlanco']	=	'SI';
		
		$query		= Doctrine::getTable('OrdenDeCompra')->GetPendientesDeValidar( $filters );
		 return $query;
		 /*
		$ordenes = $query->execute();
		
		$ordenesCompraPendientes = array();
		
		foreach($ordenes as $o)
		{
			if($o->IsPendienteDeValidar())
				$ordenesCompraPendientes[] = $o;
		
		}
		
		
		return $ordenesCompraPendientes;*/
	}
	
	public function GetFacturaCompra($facturaNumero, $tipoIvaId)
	{
		$filters = array();
		$filters['Numero'] = $facturaNumero;
		$filters['ProveedorId'] = $this->Id;
		$filters['TipoIvaId'] = $tipoIvaId;
		
		$q		= Doctrine::getTable('FacturaCompra')->GetByFilter($filters);
		//echo $q->getSqlQuery();
		$facturas = $q->execute();
		foreach ($facturas as $f)
		{
			return $f;
		}
	}
	
	public function GetPorcentajeIva()
	{
		if(!isset($this->TipoIvaId))
			throw new Exception('Debe ingresar el tipo de iva en el proveedor '. $this->Nombre);
		
		$porcentaje	=	 number_format($this->TipoIva->GetPorcentajeIva(), 2, '.', '');
		
		if(!isset($porcentaje))
			throw new Exception('Debe ingresar un porcenje de iva');
		
		//if($porcentaje > 0)
			//throw new Exception('El porcentaje de iva '.$porcentaje.' no es numerico');
						
		return $porcentaje;
	}
	
	public function GetFacturasDeCompraPendientes($data)
	{
		// limpiar ordenes de compra agregadas en sesion
		$s	=	new Classes_Session();
		$s->LimpiarFacturasDeCompraLiquidacionOrdenDePago();
		$s->LimpiarPagosLiquidacionOrdenDePago();
		////////////////////////////////////////////
		$filters		=	array();
		$filters['ProveedorId']	=	$this->Id;
		$filters['TipoDePago']	=	$data['TipoDePago'];
		
		$query		= Doctrine::getTable('FacturaCompra')->GetPendientesDePago( $filters );
		$facturasCompra = $query->execute();
		
		$facturasCompraPendientes = array();
		
		foreach($facturasCompra as $o)
		{
			if($o->IsPendienteDePago())
				$facturasCompraPendientes[] = $o;
		
		}
		
		
		return $facturasCompraPendientes;
	}	
	
	public function AgregarFacturaCompraAOrdenDePago($data)
	{
		if(	($data['ImporteLiquidado'] < 0) || ($data['ImporteLiquidado'] == 'Importe') || ($data['ImporteLiquidado'] == ''))
			throw  new Exception('Debe ingresar el importe a liquidar');
		
		$s	=	new Classes_Session();
		$s->AgregarFacturaCompraLiquidacionOrdenDePago($data);
	}
	
	public function CrearOrdenDePago($data)
	{
		$s	=	new Classes_Session();
		// validaciones
		if(!isset($data))
			throw new Exception('Faltan datos para crear la orden de pago');
		
		// debe tener detalle de pago
		if($s->GetPagosLiquidadosOrdenDePago() <= 0)
			throw new Exception('Debe agregar detalle de pago');
		// debe tener importe liquidado (facturas)
		if($s->GetImporteLiquidadoOrdenDePago() <= 0)
			throw new Exception('Debe liquidar ordenes de compra o facturas');
		
		// el importe liquidado debe ser igual al detalle de pago, sino no crear OC compensacion hasta determinada diferencia (exceso o menor importe)
		if(isset($data['Adelanto']) && ($data['Adelanto']=='NO'))
		if(
				number_format($s->GetImporteLiquidadoOrdenDePago(),2, '.','') !=
				number_format($s->GetTotalPagosLiquidadosOrdenDePago(),2, '.','')
		)
			throw new Exception('Debe coincidir el importe liquidado con el detalle de pago');
		
		$op	=	new OrdenDePago();
		
		if(!is_object($op))
			throw new Exception('No fue creada la orden de pago');
		
		$now    =   new DateTime();
		$op->Fecha	=	$now->format('d/m/Y H:i:s');
		
		// primero se asigna el tipo de pago ya que determina la numeracion a seguir (B o N)
		$op->TipoDePago	=	$op->GetTipoSegunLiquidacion();
		$op->Numero	=	$op->GetProximoNumero();
		
		$op->Importe	=	$op->GetImporteLiquidadoFacturasCompra();
		$op->ProveedorId	=	$this->Id;
		$op->Comentario	=	$data['Comentario'];
		
		$conn = Doctrine_Manager::connection();
		/*
		try
		{
			*/ 
			$conn->beginTransaction();
		
			$op->save();
		
			$op->AgregarLiquidacionFacturasCompra();
			// si es anticipo
			$op->AgregarLiquidacionOrdenesDeCompra();
			$op->AgregarDetalleDePago();
				
			$conn->commit();
		/*
		}
		catch(Doctrine_Exception $e)
		{
			$conn->rollback();
			throw new Exception($e->errorMessage('No fue posible crear la orden de pago'));
		}
		*/
		
		return $op;
		
	}
	
	public function AgregarPagoAOrdenDePago($data)
	{
		if($data['PagoTipoId'])
		{
		switch ($data['PagoTipoId']) {
			case 1:
				{
					// si es cheque propio al pagar, debe tener importe
					if(!$data['Banco'])
						throw new Exception('Debe seleccionar un banco');
						
					$banco		= Doctrine::getTable('Banco')->FindOneById($data['Banco']);
				
					if(!is_object($banco))
					{
						throw new Exception('El banco ingresado no existe');
					}
				
					if(	($data['ImporteCheque'] < 0) || ($data['ImporteCheque'] == 'Importe') ||
							($data['ImporteCheque'] == ''))
						throw  new Exception('Debe ingresar el importe del cheque a liquidar');
					
					break;
				}
				case 13:
					{
					// 	si es transferencia, debe estar asociada a un banco y una cuenta
							if(!$data['Banco'])
								throw new Exception('Debe ingresar el codigo del banco');
							
							$banco		= Doctrine::getTable('Banco')->FindOneById($data['Banco']);
							
							if(!is_object($banco))
							{
								throw new Exception('El codigo de banco ingresado no existe');
							}
							
						break;
					}
				case 4:
						{
							$cheque		= Doctrine::getTable('Cheque')->FindOneById($data['ChequeId']);
								
							if(!is_object($cheque))
							{
								throw new Exception('El cheque para pagar no existe');
							}
							
							break;
						}
				case 6: {
							$Pago	=	Doctrine::getTable('CobranzaDetalle')->findOneById($data['RetencionId']);
							
							if(!is_object($Pago))
							{
								throw new Exception('La retencion para pagar no existe');
							}
							
							break;
						}
				case 7: {
							$Pago	=	Doctrine::getTable('CobranzaDetalle')->findOneById($data['RetencionId']);
								
							if(!is_object($Pago))
							{
								throw new Exception('La retencion para pagar no existe');
							}
								
							break;
						}	
				case 8: {
							$Pago	=	Doctrine::getTable('CobranzaDetalle')->findOneById($data['RetencionId']);
								
							if(!is_object($Pago))
							{
								throw new Exception('La retencion para pagar no existe');
							}
								
							break;
						}
				case 9: {
							$Pago	=	Doctrine::getTable('CobranzaDetalle')->findOneById($data['RetencionId']);
								
							if(!is_object($Pago))
							{
								throw new Exception('La retencion para pagar no existe');
							}
								
							break;
						}
				case 10: {
							$Pago	=	Doctrine::getTable('CobranzaDetalle')->findOneById($data['RetencionId']);
								
							if(!is_object($Pago))
							{
								throw new Exception('La retencion para pagar no existe');
							}
								
							break;
						}
				case 11: {
							$Pago	=	Doctrine::getTable('CobranzaDetalle')->findOneById($data['RetencionId']);
								
							if(!is_object($Pago))
							{
								throw new Exception('La retencion para pagar no existe');
							}
								
							break;
						}
				case 12: {
							$Pago	=	Doctrine::getTable('FacturaCompra')->findOneByNumeroInterno($data['NotaCreditoId']);
						
							if(!is_object($Pago))
							{
								throw new Exception('La nota de credito para pagar no existe');
							}
						
							break;
						}	
			default:
				{
					if(	($data['Importe'] < 0) || ($data['Importe'] == 'Importe') ||
							($data['Importe'] == ''))
						throw  new Exception('Debe ingresar el importe a liquidar');
					
					break;
				}
		}
		
		}
		else
		{
			if(!isset($data['RetencionId']))
			{
				// si no tiene tipo de pago y viene un cheque como pago (es tipo 4)
				$cheque		= Doctrine::getTable('Cheque')->FindOneById($data['ChequeId']);
				
				if(!is_object($cheque))
				{
					throw new Exception('El cheque para pagar no existe');
				}
			}
		}
				
		
		$s	=	new Classes_Session();
		$s->AgregarPagoAOrdenDePago($data);
	}
	
	/*
	 * - ordenes de compra pendientes de liquidar:
		son todas las ordenes de compra en negro
		mas todas las ordenes de compra en blanco que tengan importe pendiente de validar
		-------------------
		---- ordenes de compra pendientes de liquidar:
        - son todas las ordenes de compra que tienen importe pendiente de pago en negro para un proveedor determinado
	 */
	public function GetOrdenesDeCompraPendientesDePago($data)
	{
		 // limpiar ordenes de compra agregadas en sesion
		 $s	=	new Classes_Session();
		 $s->LimpiarOrdenesDeCompraLiquidacionOrdenDePago();
		 ////////////////////////////////////////////
		 $filters		=	array();
		 $filters['ProveedorId']	=	$this->Id;
		 $filters['TipoDePago']	=	$data['TipoDePago'];
		 
		 $query		= Doctrine::getTable('OrdenDeCompra')->GetPendientesDeValidar( $filters );
		 return $query;
		 /*
		 $ordenes = $query->execute();
		 
		 $ordenesCompraPendientes = array();
		 
		 foreach($ordenes as $o)
		 {
		 	// si el importe total de la orden de compra ya fue validada en una o varias FC,
		 	// no debe mostrarse porque se paga a traves de la FC (indirectamente)
		 	// BUG (9/6/2013): no incluir las que sean de OP anulada o FC anulada
		 	// BUG (13/02/2014): no muestra OC que muestra el listado de OC pendientes de validar (deben coincidir)
		 	if($o->IsPendienteDePago())
		 		$ordenesCompraPendientes[] = $o;
		 
		 }
		 
		 
		 return $ordenesCompraPendientes;*/
	}
	
	public function GetSaldo()
	{
		$filters	=	array();
    	$filters['ProveedorId']	=	$this->Id;
    	$cc	=	new Classes_CuentaCorrienteManager($filters);
    	return $cc->GetSaldoProveedor($filters);
	}
		
}