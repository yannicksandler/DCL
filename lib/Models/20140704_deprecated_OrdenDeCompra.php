<?php

/**
 * OrdenDeCompra
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id: Builder.php 6820 2009-11-30 17:27:49Z jwage $
 */
class OrdenDeCompra extends BaseOrdenDeCompra
{
	
	
	public function setUp()
    {
        parent::setUp();
        
        //$this->hasAccessor('Fecha', 'FechaAccessor');
        
        $this->hasAccessorMutator('Fecha', 'FechaAccessor', 'FechaMutator');
    }
    
    /**
     * cuando se genera una orden de compra,
     * la orden de trabajo asociada cambia a
     * estado 'EN PRODUCCION'
     * */
    
	public function postInsert( $event)
    {
    	// si la orden de compra es en negro -> generar factura compra en negro
    	if($this->EsEnNegro())
    		$this->CrearFacturaCompraNegro();
        
    }
    
      
    public function FechaMutator( $value )
    {
        $dateHelper =   new Classes_DateHelper();
    	$date 	=	$dateHelper->fromViewFormat($value);
    	
    	
        $this->_set('Fecha', $date);
    }
  
    
    public function FechaAccessor()
    {
    	$timestamp	=	$this->_get('Fecha');
    	
    	if ($timestamp)
    	{
    		// convertir timestamp a dd/mm/aaaa
		    $dateHelper =   new Classes_DateHelper();
    	
        	$date 	=	$dateHelper->toViewFormat($timestamp);
        	
        	return substr($date, 0, 10);
    	}
    	else
    		return '';
    }
    
    public function GetOneInsumo()
    {
    	
    	$insumos	=	$this->Insumo;
    	
    	foreach($insumos as $i)
    	{
    		return $i;
    	}
    }
    // mal delegacion de responsabilidades.
    // el proveedor deberia crear una OP
    /*
    public function CrearOrdenDePago()
    {
    	$a	=	new	OrdenDePago();
    	$now    =   new DateTime();
            
    	$a->Fecha	=	$now->format('d/m/Y H:i:s');
    	$InsumoImporte	=	$this->GetOneInsumo()->GetTotal();
    	$a->Importe	=	$InsumoImporte; 
    	// se crea con el importe del insumo asociado la orden

    	$a->save();
    	
    	$this->OrdenDePagoId	=	$a->Id;
    	$this->save();
    }
    */
    /*
    public function IsPaga()
    {
    	if($this->Pagado == 'S')
    		return true;
    		
    	return false;
    }
    */
    public function SetPago()
    {
    	/*
    	if($this->OrdenDePago->EstaPago())
    	{
	    	$this->Pagado	=	'S';
	    	$this->save();
	    	
	    	$OrdenDeTrabajo	=	$this->GetOrdenDeTrabajo();
	    	
	    	*
	    	 * al pagar una orden de compra, se verifica si la orden
	    	 * de trabajo asociada tiene todos sus insumos pagos,
	    	 * de ser asi, cambia el estado de la orden de trabajo
	    	 * a FINALIZADO
	    	 *
	    	
	    	if($OrdenDeTrabajo->IsPaga())
	    	{
	    		
	    		$OrdenDeTrabajo->SetEstadoFinalizado();
	    	}
    	}
    	*/
    }
    
    public function GetOrdenDeTrabajo()
    {
    	$insumo	=	$this->GetOneInsumo();
    	
    	if(is_object($insumo))
    		return $insumo->Orden;
    	else
    		echo 'No tiene insumo asociado';
    		
    }
    
    public function GetOrdenDeTrabajoId()
    {
    	$insumo	=	$this->GetOneInsumo();
    	 
    	if(is_object($insumo))
    		return $insumo->Orden->Id;
    	else
    		echo 'No tiene insumo asociado';
    
    }
    
    public function GetNombreProveedor()
    {
    	return $this->GetOneInsumo()->Proveedor->Nombre;
    }
    
    public function Anular()
    {
    	/* solo anular si NO tiene orden de pago creada */
    	//HACER
    	if(!$this->HasOrdenDePago())
    	{
	    	$this->FechaAnulacion = date('Y-m-d');
	    	$this->save();
	    	
	    	$this->InsumoNoPuedeEstarElegido();
	    	// BUG: 2013-09-30 al anular OC, anular FCs asociada
	    	$this->AnularFacturaDeCompra();
    	}
    	else
    		echo 'La orden tiene orden de pago y no puede ser anulada';
    	
    }
    
    public function AnularFacturaDeCompra()
    {
    	// validaciones asociadas a orden de compra
    	$q	=	Doctrine_Query::create()
    	->from('FacturaCompraOrdenDeCompra fcoc')
    	->andWhere('fcoc.OrdenDeCompraId = ?', $this->Id);
    	
    	$facturasOrdenesCompra	=	$q->execute();
    	foreach ($facturasOrdenesCompra as $fcoc)
    	{
    	 	// obtener FC asociada y anular
    		$qfc	=	Doctrine_Query::create()
    		->from('FacturaCompra f')
    		->andWhere('f.TipoIvaId = ?', $fcoc->TipoIvaId)
    		->andWhere('f.ProveedorId = ?', $fcoc->ProveedorId)
    		->andWhere('f.Numero = ?', $fcoc->FacturaNumero)
    		->limit(1);
    		
    		$fc	=	$qfc->fetchOne();
    		if(is_object($fc))
    		{
    			$fc->Anular();
    			
    			$fc->PendienteDePago = 'NO';
    			$fc->Comentario	=	$fc->Comentario += 
    								'. Factura anulada por anular la OC #'.$this->Id.'.';
    			$fc->save();
    		}
    	}
    	
    }
    
  	public function HasOrdenDePago()
  	{
  		if($this->OrdenDePagoId)
  			return true;
  			
  		return false;
  	}
    
    public function InsumoNoPuedeEstarElegido()
    {
    	$insumo	=	$this->GetOneInsumo();
    	$insumo->Elegido = 'NO';
    	$insumo->save();
    }
    
    /**
     * @deprecated 21/2/2013
     * Se agrega propiedad importe a la orden de compra
     
    public function GetImporte()
    {
    	$number	=	$this->GetOneInsumo()->GetTotal();
    	
    	return number_format($number, 3, '.', '');
    }
    */
    /*
    public function TieneImportePendienteEnOrdenDePago()
    {
    	$importeAbonado = $this->GetTotalLiquidadoEnOrdenDePago();
    	$importeTotal = $this->Importe;
    	
    	if($importeTotal > $importeAbonado)
    		return true;
    	
    	return false;
    }
    */
    public function GetTotalLiquidadoEnOrdenDePago()
    {
    	$suma = 0;
    	// BUG (9/6/2013): no contar  las OP anuladas
    	$q  =   Doctrine_Query::create()
	    	->from('OrdenDePagoOrdenDeCompra o')
	    	->innerJoin('o.OrdenDePago op')
	    	->andWhere('op.FechaAnulacion IS NULL') // no debe estar anulada
	    	->andWhere('o.OrdenDeCompraId = ?', $this->Id);
    	
    	$pagos = $q->execute();
    	
    	foreach($pagos as $p)
    	{
    		$suma = $suma + $p->ImporteAbonado;
    	}
    	
    	return $suma;
    }
    
    public function AgregarOrdenDeCompraAFactura($data)
    {
    	if(	($data['ImporteLiquidado'] < 0) || ($data['ImporteLiquidado'] == 'Importe') || ($data['ImporteLiquidado'] == ''))
    		throw  new Exception('Debe ingresar el importe a liquidar');
    	
    	// CONTROL: el importe total validado de cada OC no supere el importe total de la OC
    	$totalQueSeDeseaValidar = $data['ImporteLiquidado'] + $this->GetTotalValidadoEnFacturaCompra();
    	
    	// si es compensatoria, calcular importe compensatorio
    	if($data['Compensatoria']=='true')
    	{
    		// obtener maximo importe compensatorio permitido de configuracion
    		$Configuracion = Doctrine::GetTable ( 'Configuracion' )->FindOneByNombre('MaximoImporteCompensatorio');
    		if(!is_object($Configuracion))
    			throw new Exception('Debe crear el valor de configuracion MaximoImporteCompensatorio');
    			
    		$MaximoImporteCompensatorio	=	$Configuracion->Valor;
    		
    		$importeCompensatorio = abs($totalQueSeDeseaValidar - $this->Importe);

    		// el usuario administrador puede validar por cualquier monto de diferencia. 
    		// Indte. del MaximoConfigurado
    		$s	= new Classes_Session();
    		if(!$s->GetUser()->IsPerfilAdministrador())
    		{
	    		if($importeCompensatorio > $MaximoImporteCompensatorio)
	    			throw  new Exception('El importe compensatorio no puede superar el importe maximo permitido ($'.$MaximoImporteCompensatorio.')');
    		}
    		
    		//var_dump($importeCompensatorio);
    	}
    	else
    	{
    		// si no es compensatoria, no puede liquidarse importe mayor
	    	if($totalQueSeDeseaValidar > $this->Importe)
	    		throw new Exception('No es posible validar un importe mayor a la orden de compra');
    	}
    	//print_r($data);
    	$s	=	new Classes_Session();
    	$s->AgregarOrdenDeCompraLiquidacionFacturaCompra($data);
    }
    
    public function AgregarOrdenDeCompraAOrdenDePago($data)
    {
    	if(	($data['ImporteLiquidado'] < 0) || ($data['ImporteLiquidado'] == 'Importe') || ($data['ImporteLiquidado'] == ''))
    		throw  new Exception('Debe ingresar el importe a liquidar');
    	 
    	// CONTROL: el importe total validado de cada OC no supere el importe total de la OC
    	$totalQueSeDeseaValidar = $data['ImporteLiquidado'] + $this->GetImporteAbonado();
    	
    	if($totalQueSeDeseaValidar > $this->Importe)
    		throw new Exception('No es posible liquidar un importe mayor a la orden de compra');
    	//print_r($data);
    	$s	=	new Classes_Session();
    	$s->AgregarOrdenDeCompraLiquidacionFacturaCompra($data);
    }
    
    
    public function ExisteDiferenciaDeImporte($data)
    {
    	if($this->Importe != $data['Importe'])
    		return true;
    	
    	return false;
    }
    
    /* una OC esta pendiente de liquidar si
     * - no esta anulada Y tiene importe pendiente de liquidar
     */
    public function IsPendienteDeLiquidar()
    {
    	if($this->EstaAnulada())
    		return false;
    	
    	if($this->GetImportePendienteDeValidar())
    		return true;
    	
    	// si tiene importe pendiente
    	if($this->GetImportePendiente() > 0)
    		return true;
    	
    	return false;
    }
    
    public function EstaAnulada()
    {
    	if($this->FechaAnulacion)
    		return true;
    	
    	return false;
    }
    
    public function EstaLiquidadaEnFactura()
    {
    	if(!$this->TieneImportePendienteEnFacturaCompra())
    		return true;
    	 
    	return false;
    }
    
    public function EstaLiquidadaEnOrdenDePago()
    {
    	if(!$this->TieneImportePendienteEnOrdenDePago())
    		return true;
    	
    	return false;
    }
    
    public function TieneImportePendienteEnFacturaCompra()
    {
    	$importeAbonado = $this->GetTotalValidadoEnFacturaCompra();
    	$importeTotal = $this->Importe;
    	 
    	if($importeTotal > $importeAbonado)
    		return true;
    	 
    	return false;
    }
    
    public function GetTotalValidadoEnFacturaCompra()
    {
    	$suma = 0;
    	 
    	// BUG (9/6/2013): no contar  las FC anuladas
    	// buscar las validaciones de una OC
    	$q  =   Doctrine_Query::create()
    	->from('FacturaCompraOrdenDeCompra o')
    	->andWhere('o.OrdenDeCompraId = ?', $this->Id);
    	 
    	$pagos = $q->execute();
    	
    	foreach($pagos as $p)
    	{
    		// encontrar factura asociada a la liquidacion
    		$q	=	Doctrine_Query::create()
			->from('FacturaCompra f')
			->andWhere('f.TipoIvaId = ?', $p->TipoIvaId)
			->andWhere('f.ProveedorId = ?', $p->ProveedorId)
			->andWhere('f.Numero = ?', $p->FacturaNumero)
			->andWhere('f.FechaAnulacion IS NULL')
			->limit(1);
			
			//echo $q->getSqlQuery();
			$fc	=	$q->fetchOne();
			if(is_object($fc))
			{
				if(!$fc->EstaAnulada())
    				$suma = $suma + $p->ImporteLiquidado; 
				// sumar el importe validado en cada factura de compra
			}
    	}
    	 
    	return number_format($suma,2, '.','');
    }
    
	public function GetImportePendienteDePago()
	{
		 return number_format(($this->Importe - $this->GetImporteAbonado()),2, '.',''); // modificacion 11/09/2013
	}
    
    public function GetImportePendienteDeValidar()
    {
    	return $this->Importe - $this->GetTotalImporteValidado();
    }
    
    public function GetTotalImporteValidado()
    {
    	return $this->GetTotalValidadoEnFacturaCompra();
    }
    
    /* obtener factura de compra asociada y obtener importe liquidado */
    public function GetImporteLiquidadoEnFacturaCompra()
    {
    	$suma = 0;
    
    	$q  =   Doctrine_Query::create()
    	->from('FacturaCompraOrdenDeCompra o')
    	->andWhere('o.OrdenDeCompraId = ?', $this->Id);
    
    	$pagos = $q->execute();
    	 
    	foreach($pagos as $p)
    	{
    		$suma = $suma + $p->ImporteLiquidado;
    	}
    
    	return $suma;
    }
    
    public function GetNombreInsumo()
    {
    	$i	=	$this->GetOneInsumo();
    	
    	return $i->Nombre;
    }
    
    public function EsEnNegro()
    {
    	if($this->TipoIva->Letra_comp == 'N')
    		return true;
    	
    	return false;
    }
    
    public function GetEntregado()
    {
    	$insumo	=	$this->GetOneInsumo();
    	if($insumo->FechaDeEntrega)
    		return 'Entregado';
    	
    	return 'No entregado';
    }
    
    public function GetFechaEntregaInsumo()
    {
    	$insumo	=	$this->GetOneInsumo();
    	if($insumo->FechaDeEntrega)
    		return $insumo->FechaDeEntrega;
    }
    // utilizado al crear factura de compra
    public function TotalLiquidadoSuperaImporteTotal($importeParaLiquidar=null)
    {
    	$liq	=	$this->GetTotalLiquidado() + $importeParaLiquidar;
    	//var_dump($liq);
    	if($liq > $this->Importe)
    	{
    		//echo '++++++++++++ hacer TotalLiquidadoSuperaImporteTotal';
    		return true;
    	}
    	
    	return false;
    }
    
    public function GetFormaDePago()
    {
    	$o	=	$this->GetOneInsumo();
    	
    	if($o->FormaDePago != '')
    		return $o->FormaDePago;
    	
    	return 'Sin forma de pago';
    }
    /* la OC se valida ingresando importes a las facturas de compra
     * hasta completar importe
     * - una orden de comra esta pendiente de validar si queda importe pendiente de validar
     */
    public function IsPendienteDeValidar()
    {
    	// si esta anulada no puede validarse
    	if($this->EstaAnulada())
    		return false;
    	
    	// si es en negro, no puede validarse porque se crea una FC en negro 
    	// que la valida automaticamente por el total del importe
    	if($this->EsEnNegro())
    		return false;
    	/*
    	 * BUG: no deja obtener OC pendientes de validar para proveedor Marcelo Passerini
    	 * RESUELTO: 1/8/2013 
    	 *
    	if(!$this->IsPendienteDePago())
    		return false;
    	*/
    	
    	// si tiene importe pendiente de validar
    	if($this->GetImportePendienteDeValidar() > 0)
    		return true;
    	// no contemplado
    	return false;
    }
    
    // si el total liquidado en ordenes de pago y
    // validado en FC es menor al importe total de la OC
    public function IsPendienteDePago()
    {
    	$totalLiquidado	=	$this->GetTotalLiquidadoEnOrdenDePago() +
    						$this->GetTotalValidadoEnFacturaCompra();
    	if($totalLiquidado < $this->Importe)
    		return true;
    	
    	return false;
    }
    /*
     * @deprecated 18/04/2013
     */
    public function GetTotalLiquidado()
    {
    	$importeLiquidado	=	0;
    	
    		// sumar (importes liquidados en ordenes de pago) mas (importes validados en facturas de compra)
    	$importeLiquidado = $this->GetTotalLiquidadoEnOrdenDePago() +
    						$this->GetTotalValidadoEnFacturaCompra();
    	
    	
    	return $importeLiquidado;
    }
    
    public function CrearFacturaCompraNegro()
    {
    	$data = array();
    	
    	$data['Fecha']	=	date('d/m/Y');
    	$data['ImporteNetoNoGravado'] = $this->Importe;
    	$data['TipoIvaId'] = $this->GetTipoIvaNegro();
    	$data['Numero'] = Doctrine::getTable('FacturaCompra')->GetProximoNumeroFactura('N');
    	$data['Comentario'] = 'generada automaticamente';
    	
    	$s	=	new Classes_Session();
    	$s->LimpiarOrdenDeCompraLiquidacionFacturaCompra();
    	
    	$f	=	new Classes_FacturaCompraFactory($this->Proveedor, $data);
    	$f->AgregarLiquidacion($this);
    	
    	return $f->CrearFactura();
    	
    }
    
    public function GetTipoIvaNegro()
    {
    	return  Doctrine::getTable('TipoIva')->GetTipoIvaNegroId();
    	
    }
    
    public function GetTextDescripcion()
    {
    	return 'OC #'. $this->Id . ' ('.$this->GetEntregado() . ') - '.$this->CondicionesDePago;
    }
    
    public function GetImporteAbonado()
    {
    	$total = 0.0;
    	
    	$q	=	Doctrine_Query::create()
    	->from('OrdenDePagoOrdenDeCompra o')
    	->andWhere('o.OrdenDeCompraId = ?', $this->Id);
    	//echo $q->getsqlquery();
    	$ordenes	=	$q->execute();
    	foreach ($ordenes as $p)
    	{
    		$total = $total + $p->ImporteAbonado;
    	}
    	
    	return $total;// - $this->GetImporteAnticipo();
    }
    
    public function GetLetraTipoIva()
    {
    	return $this->TipoIva->Letra_comp;
    }
    
    public function GetImporteCompensatorioSinIVA()
    {
    	$factorIva	=	1+($this->TipoIva->GetPorcentajeIva()/100); //1.21 o 1.10 o 1.27
    	
    	$importeSinIVA = ($this->ImporteCompensatorio / $factorIva);
    	
    	return number_format($importeSinIVA,2, '.','');
    }
}